# Software Design Document 300 | Fourier Series Synthesis on K22F

## Overview
The scope of this document is limeted to describing the theoretical modeling of a Fourier series synthesizer that generates arbitrary periodic waveforms using truncated harmonic summation.

## Parameters


---

## Mathematical Foundation

### Base Signal Definition

$$
x(t) = \begin{cases}
0 & -20 \leq t < -(B + 10) \\
-t/(B + 10) & -(B + 10) \leq t < 0 \\
2t/(A + 10) & 0 \leq t < A + 10 \\
0 & A + 10 \leq t < 20 \\
x(t + 40) & \forall
\end{cases}
$$

Given:
- **A = 1**
- **B = 3**

### Signal Characteristics
- **Period:** T = 40 seconds (theoretical)
- **Fundamental frequency:** f₀ = 1/T = 0.025 Hz (theoretical)
- **Piecewise linear:** Two ramp segments with different slopes
- **DC component:** Non-zero (signal not symmetric about zero)

### Transformed Signal
The output signal is defined as:

$$
y(t) = c_{1} + c_{2} x(c_{3} t)
$$

Where:
- c₁ = DC offset for centering
- c₂ = Amplitude scaling
- c₃ = Time scaling (frequency multiplication)

### Fourier Series Representation
The truncated Fourier series approximation:

$$
y_{K}(t) = \sum_{k=-K}^{K} Y_k e^{jk\omega_{0} t}
$$

For real signals, this can be rewritten as:

$$
y_{K}(t) = Y_0 + 2\sum_{k=1}^{K} |Y_{k}| \cos(k\omega_{0} t + \phi_{k})
$$

Or equivalently:

$$
y_{K}(t) = a_{0} + \sum_{k=1}^{K} [a_{k} \cos(k\omega _{0} t) + b_{k} \sin(k \omega_{0} t)]
$$

---

## Part (a): Signal Visualization

### MATLAB Implementation
```matlab


```

---

## Part (b): Scaling Constants c₁ and c₂

### Objective
Maximize output amplitude while preventing saturation on 12-bit DAC (0-4095 range).

### Analysis
The K22F DAC requires:
- **Output range:** 0 to 4095 (12-bit unsigned)
- **Voltage range:** 0 to 3.3V
- **Recommended buffer:** ~10% headroom to prevent clipping

**DC offset (c₁):**
```
c₁ = 4095/2 = 2047.5 ≈ 2048
```
Centers the signal at mid-scale.

**Amplitude scaling (c₂):**

Given that x(t) has maximum value max(x) and minimum value min(x), the peak-to-peak amplitude is:
```
A_pp = max(x) - min(x)
```

With 10% headroom:
```
c₂ = 0.9 × (4095/2) / max(|x(t)|)
c₂ ≈ 1840 / max(|x(t)|)
```

**Result:**
- c₁ = 2048
- c₂ = [CALCULATE BASED ON YOUR A, B VALUES]

---

## Part (c): Frequency Scaling c₃

### Constraints
- **Sample rate:** Fs = 10 kHz
- **Nyquist frequency:** Fs/2 = 5 kHz
- **Signal quality:** Must maintain acceptable waveform for K ≤ 10

### Analysis
The highest frequency component in yK(t) is:
```
f_max = K × f₀ × c₃
```

For adequate reconstruction with K=10 harmonics, we need significant margin below Nyquist:
```
10 × f₀ × c₃ < 0.8 × (Fs/2)  [80% of Nyquist as safety margin]
10 × (1/40) × c₃ < 4000
c₃ < 16000
```

However, for better signal quality with K=1 (fundamental only), we want the base frequency high enough to be audible/visible:
```
f₀ × c₃ > 100 Hz  [reasonable lower bound]
c₃ > 4000
```

**Recommended value:**
```
c₃ = 8000-12000  [adjust based on MATLAB testing]
```

This gives:
- Fundamental: 200-300 Hz (K=1)
- 10th harmonic: 2-3 kHz (K=10)

---

## Part (d): Fourier Series Coefficients

### Derivation
For a periodic signal with period T, the Fourier series coefficients are:

$$
Y_k = \frac{1}{T} \int_{0}^{T} y(t) e^{-jk\omega_0 t} dt
$$

Since y(t) = c₁ + c₂x(c₃t), and x(t) is piecewise linear:

**DC component (k=0):**
$$
Y_0 = c_1 + \frac{c_2}{T} \int_{0}^{T} x(c_3 t) dt
$$

**Harmonic components (k≠0):**

For the piecewise segments, integration by parts:
$$
\int t e^{-j\omega t} dt = \frac{t}{-j\omega} e^{-j\omega t} - \frac{1}{-j\omega} \int e^{-j\omega t} dt
$$

$$
= \frac{-jt}{\omega} e^{-j\omega t} + \frac{1}{\omega^2} e^{-j\omega t}
$$

[COMPLETE THE DERIVATION FOR YOUR SPECIFIC A, B VALUES]

### MATLAB Coefficient Calculation
```matlab
% Fundamental frequency after scaling
T_new = T / c3;
omega0 = 2*pi / T_new;
K_max = 10;

% Preallocate coefficient arrays
Y_k = zeros(1, 2*K_max + 1);

% DC component
Y_k(K_max + 1) = c1 + (c2/T) * trapz(t_period, x_period);

% Harmonic components
for k = 1:K_max
    integrand = y_scaled .* exp(-1j * k * omega0 * t_period);
    Y_k(K_max + 1 + k) = (1/T_new) * trapz(t_period, integrand);
    Y_k(K_max + 1 - k) = conj(Y_k(K_max + 1 + k));  % Conjugate symmetry
end

% Convert to real coefficients (a_k, b_k form)
a0 = real(Y_k(K_max + 1));
ak = 2 * real(Y_k(K_max + 2:end));
bk = -2 * imag(Y_k(K_max + 2:end));
```

### Plotting K=1 through K=10
```matlab
figure;
for K = 1:10
    subplot(5, 2, K);

    % Reconstruct signal
    y_reconstructed = a0 * ones(size(t));
    for k = 1:K
        y_reconstructed = y_reconstructed + ...
            ak(k) * cos(k * omega0 * t) + ...
            bk(k) * sin(k * omega0 * t);
    end

    plot(t, y_reconstructed, 'LineWidth', 1.5);
    grid on;
    title(sprintf('K = %d', K));
    ylim([0 4095]);
end
```

---

## Part (e): Algorithm Design for K22F

### Avoiding Complex Numbers
Since C doesn't natively support complex arithmetic, use the real form:

$$
y_K(t) = a_0 + \sum_{k=1}^{K} [a_k \cos(k\omega_0 t) + b_k \sin(k\omega_0 t)]
$$

### MATLAB Prototype (C-style)
```matlab
% Precompute coefficient tables
a_coeffs = zeros(1, K_max);
b_coeffs = zeros(1, K_max);

for k = 1:K_max
    a_coeffs(k) = ak(k);
    b_coeffs(k) = bk(k);
end

% Synthesis function (C-compatible style)
function y = synthesize_sample(sample_num, K, a0, a_coeffs, b_coeffs, omega0, Fs)
    t = sample_num / Fs;  % Current time
    y = a0;  % DC component

    % Sum harmonics (explicit loop, no vectorization)
    for k = 1:K
        phase = k * omega0 * t;
        y = y + a_coeffs(k) * cos(phase) + b_coeffs(k) * sin(phase);
    end
end

% Test synthesis
Fs = 10000;  % 10 kHz
samples = 0:999;  % 100ms worth
output = zeros(size(samples));

for i = 1:length(samples)
    output(i) = synthesize_sample(samples(i), K, a0, a_coeffs, b_coeffs, omega0, Fs);
end
```

### Optimization Considerations
**Option 1: Direct computation (simple but slow)**
```matlab
for k = 1:K
    phase = k * omega0 * sample_num / Fs;
    y = y + a_k(k) * cos(phase) + b_k(k) * sin(phase);
end
```

**Option 2: Lookup table (fast but memory intensive)**
```matlab
% Precompute one period of samples
period_samples = round(Fs / f0);
lut = zeros(1, period_samples);

for n = 0:period_samples-1
    lut(n+1) = synthesize_sample(n, K, ...);
end

% During ISR:
y = lut(mod(sample_counter, period_samples) + 1);
```

**Option 3: Recursive cosine (balanced)**
Using the recurrence relation:
```
cos((n+1)q) = 2cos(q)cos(nq) - cos((n-1)q)
```

[CHOOSE BASED ON K22F PERFORMANCE TESTING]

---

## Part (f): K22F Implementation

### System Architecture
```
Timer ISR (10 kHz) → Synthesize Sample → DAC Output
      ↓
   LED Toggle
      ↓
Button Check → Adjust K → Update Coefficients (optional)
```

### C Implementation Structure
```c
// Coefficient storage
#define K_MAX 10
static float a0;
static float a_coeffs[K_MAX];
static float b_coeffs[K_MAX];
static float omega0;

// Runtime variables
static volatile uint8_t K_current = 1;
static volatile uint32_t sample_counter = 0;

// Synthesis function
uint16_t synthesize_sample(void) {
    float t = (float)sample_counter / 10000.0f;  // Current time
    float y = a0;

    // Sum K harmonics
    for(uint8_t k = 1; k <= K_current; k++) {
        float phase = (float)k * omega0 * t;
        y += a_coeffs[k-1] * cosf(phase) + b_coeffs[k-1] * sinf(phase);
    }

    sample_counter++;

    // Clamp to DAC range
    if(y < 0.0f) y = 0.0f;
    if(y > 4095.0f) y = 4095.0f;

    return (uint16_t)y;
}

// Timer ISR
void PIT0_IRQHandler(void) {
    LED_ON();  // Timing measurement

    uint16_t dac_value = synthesize_sample();
    DAC_Write(dac_value);

    LED_OFF();

    PIT->CHANNEL[0].TFLG = PIT_TFLG_TIF_MASK;  // Clear flag
}

// Button handlers
void increase_K(void) {
    if(K_current < K_MAX) {
        K_current++;
    }
}

void decrease_K(void) {
    if(K_current > 1) {
        K_current--;
    }
}
```

### Coefficient Initialization
```c
void init_coefficients(void) {
    // Copy from MATLAB calculation
    a0 = 2048.0f;

    // Example (replace with actual values):
    a_coeffs[0] = 123.45f;  // k=1
    a_coeffs[1] = 67.89f;   // k=2
    // ... etc

    b_coeffs[0] = -45.67f;  // k=1
    b_coeffs[1] = 23.45f;   // k=2
    // ... etc

    omega0 = 2.0f * 3.14159f * (c3 / 40.0f);
}
```

---

## Part (g): Hardware Validation

### Oscilloscope Measurements

**Waveform verification (K=1 through K=10):**
- Measure period: Should match T/c₃
- Measure amplitude: Should stay within DAC range
- Visual inspection: Waveform convergence to ideal shape

**ISR timing measurement:**
1. LED turns ON at ISR entry
2. LED turns OFF at ISR exit
3. Measure pulse width with scope

**Calculations:**
```
ISR_time = LED_pulse_width
Sample_period = 1/10kHz = 100 µs
CPU_load = (ISR_time / Sample_period) × 100%
```

Expected results:
- K=1: ~5-10 µs (5-10% load)
- K=10: ~20-40 µs (20-40% load)

### Questions to Answer

**Q: How close are your waveforms to theoretical?**
- Compare scope capture to MATLAB plot
- Quantify RMS error or visual differences
- Discuss convergence with increasing K

**Q: What percentage of processing time is used?**
- Report CPU load for each K value
- Show LED timing scope captures

**Q: Does processing time vary with K?**
- Plot ISR time vs. K
- Should be approximately linear

---

## Deliverables

1. **Hardware demonstration** (Thursday check-off)
   - Working K22F outputting waveforms
   - Button control of K
   - LED timing indicator

2. **Technical writeup**
   - Approach and design decisions
   - Coefficient derivations
   - Measurement results
   - Comparison to theory

3. **Documented C code**
   - Properly commented
   - Include coefficient values
   - Build instructions

---

## Notes & Observations

[ADD YOUR INSIGHTS HERE AS YOU WORK THROUGH THE PROBLEM]
