# Software Design Document 300 | Fourier Series Synthesis on K22F

## Overview
The scope of this document is limeted to describing the theoretical modeling of a Fourier series synthesizer that generates arbitrary periodic waveforms using truncated harmonic summation.

## Parameters


---

## Mathematical Foundation

### Base Signal Definition

$$
x(t) = \begin{cases}
0 & -20 \leq t < -(B + 10) \\
-t/(B + 10) & -(B + 10) \leq t < 0 \\
2t/(A + 10) & 0 \leq t < A + 10 \\
0 & A + 10 \leq t < 20 \\
x(t + 40) & \forall
\end{cases}
$$

Given:
- **A = 1**
- **B = 3**
In MATLAB
```matlab
A = 1;
B = 3;
T = 40;

t = -40:0.01:40;  % 2 periods

% Map t to one period [-20, 20)
t_mod = mod(t + 20, T) - 20;

x = zeros(size(t));

x(t_mod >= -(B+10) & t_mod < 0)      = -t_mod(t_mod >= -(B+10) & t_mod < 0) / (B+10);
x(t_mod >= 0 & t_mod < (A+10))       = 2*t_mod(t_mod >= 0 & t_mod < (A+10)) / (A+10);

plot(t, x);
title('x(t) - 2 Periods');
xlabel('t');
grid on;
```
![Alt text](./Artifacts/SDD_301_Artifact_1.png "Figure 1")

### Signal Characteristics
- **Period:** T = 40 units of time
- **Fundamental frequency:** f₀ = 1/T = 0.025/units Hz
- **Piecewise linear:** Two ramp segments with different slopes
- **DC component:** Non-zero (signal not symmetric about zero)

## Transformed Signal
The output signal is defined as:

$$
y(t) = c_{1} + c_{2} x(c_{3} t)
$$

Where:
- c₁ = DC offset for centering
- c₂ = Amplitude scaling
- c₃ = Time scaling (frequency multiplication)

### Fourier Series Representation
The truncated Fourier series approximation:

$$
y_{K}(t) = \sum_{k=-K}^{K} Y_{k} e^{jk\omega_{0} t}
$$


## Scaling Constants c₁ and c₂

### Objective
Maximize output amplitude while preventing saturation on 12-bit DAC (0-4095 range).

### Analysis
The K22F DAC requires:
- **Output range:** 0 to 4095 (12-bit unsigned)
- **Voltage range:** 0 to 3.3V
- **Buffer:** ~10% headroom to prevent clipping

**DC offset (c₁):**
```
c₁ = 4095/2 = 2047.5 = ~2048
```
Centers the signal at mid-scale.

**Amplitude scaling (c₂):**

Given that x(t) has maximum value max(x) and minimum value min(x), the peak-to-peak amplitude is:
```
A_pp = max(x) - min(x)
```

With 10% headroom:
```
c₂ = 0.9 * (4095/2) / max(|x(t)|)
c₂ = ~1842 / max(|x(t)|)
c₂ = 1842 / 2 = 921
```

**Result:**
- c₁ = 2048
- c₂ = 921

## Frequency Scaling c₃

### Constraints
- **Sample rate:** Fs = 10 kHz
- **Nyquist frequency:** Fs/2 = 5 kHz
- **Signal quality:** Must maintain acceptable waveform for K less than or eqaul to 10

### Analysis
The highest frequency component in yK(t) is:
```
f_max = K × f₀ × c₃
```

For adequate reconstruction with K=10 harmonics, we need significant margin below Nyquist:
```
10 × f₀ × c₃ < 0.9 × (Fs/2) [10% buffer]
10 × (1/40) × c₃ < 4500
c₃ < 18000
```

However, for better signal quality with K=1 (fundamental only), we want the base frequency high enough to be audible/visible:
```
f₀ × c₃ > 100 Hz  [reasonable lower bound]
c₃ > 4000
```

**Recommended value:**
```
c₃ = 4000-18000  [adjust based on MATLAB testing]
```
* Using c₃ = 16500 [so theres a fair margin]

```
>>> 16500 / 40
412.5
>>> 412.5 * 10
4125.0
```
This gives:
- Fundamental: 412.5 Hz (K=1)
- 10th harmonic: 4.125 kHz (K=10)

| parameter | value |
|-----------|-------|
| C_1       | 2048  |
| C_2       | 921   |
| C_3       | 16500 |

---

## Fourier Series Coefficients

### Derivation
For a periodic signal with period T, the Fourier series coefficients are:

$$
Y_k = \frac{1}{T} \int_{0}^{T} y(t) e^{-jk\omega_0 t} dt
$$

Since y(t) = c₁ + c₂x(c₃t), and x(t) is piecewise linear:

**DC component (k=0):**

$$
Y_0 = c_1 + \frac{c_2}{T} \int_{0}^{T} x(c_3 t) dt
$$

**Harmonic components (k≠0):**

For the piecewise segments, integration by parts:

$$
\int t e^{-j\omega t} dt = \frac{t}{-j\omega} e^{-j\omega t} - \frac{1}{-j\omega} \int e^{-j\omega t} dt\\
= \frac{-jt}{\omega} e^{-j\omega t} + \frac{1}{\omega^2} e^{-j\omega t}
$$

Which in Python translates to:
```python
def find_fft_k(T, function, K_max, C_1=0, C_2=1, C_3=1):
    Y_k = np.zeros(K_max+1, dtype=complex)
    omega_0 = 2 * np.pi / T

    def integrand_real(t, k):
        return function(t) * np.cos(k * omega_0 * t)

    def integrand_imag(t, k):
        return function(t) * np.sin(k * omega_0 * t)

    Y_k[0] = (C_2 / T) * integrate.quad(function, -T/2, T/2)[0] + C_1

    for k in range(1, K_max + 1):
        real_part = integrate.quad(integrand_real, -T/2, T/2, args=(k,), limit=200)[0]
        imag_part = integrate.quad(integrand_imag, -T/2, T/2, args=(k,), limit=200)[0]
        Y_k[k] = (C_2 / T) * (real_part - 1j * imag_part)

    return Y_k
```
Then to call it:

```python
on main ❮ python3
Python 3.14.2 (main, Dec 10 2025, 20:09:47) [GCC 14.2.1 20250405] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> A = 1
>>> B = 3
>>> def x(t):
...     if -(B+10) <= t < 0:
...          return -t / (B+10)
...     elif 0 <= t < (A+10):
...          return 2*t / (A+10)
...     else:
...          return 0
...
>>> import dsp_sim_utils as s
>>> Xk = s.find_fft_k(40, x, 10)
<class 'int'> <class 'int'> 1 40
>>> print(Xk)
[ 4.37500000e-01+0.j          1.29837206e-01-0.09004759j
 -2.34354926e-01-0.10612265j -1.14120681e-01+0.01265463j
  7.60403684e-02+0.07454009j  4.60652343e-03-0.0299229j
 -5.93476414e-02-0.05293962j -4.36936105e-04+0.0473512j
  2.19557396e-02+0.02493691j -7.12110187e-03-0.0514814j
 -1.85370914e-02+0.0026216j ]
>>> Y_k = X_k.copy()
>>> Y_k[0] = 921 * X_k[0] + 2048
>>> Y_k[1:] = 921 * X_k[1:]
>>> print(Y_k)
[ 2.45093750e+03 +0.j          1.19580067e+02-82.9338318j
 -2.15840887e+02-97.73895807j -1.05105147e+02+11.65491355j
  7.00331793e+01+68.65142694j  4.24260808e+00-27.55899471j
 -5.46591777e+01-48.7573927j  -4.02418152e-01+43.61045175j
  2.02212362e+01+22.96689327j -6.55853482e+00-47.41437221j
 -1.70726612e+01 +2.41449089j]
```
refer to `../../Simulation/dsp_sim_utils.py` for functions. (I wrote them myself).

---

## Sythesis

$$
x(t) = \sum_{-\infty}^{\infty}{X_{k}e^{j k \omega_{0} t}\\
= \sum_{-K}^{K}{X_{k}e^{j k \omega_{0} t}\\
$$

And by eulers identity:

$$
e^{j k \omega_{0} t} = cos(k \omega_{0} t) + jsin(k \omega_{0} t)\\
a_{k} = Re(X_{k}), b_{k} = Im(X_{k})\\
x(t) = \sum_{-K}^{K}{a_{k}cos(k \omega_{0} t) + jb_{k}sin(k \omega_{0} t)
$$

Which translated to python:
```python
def fft_synth_real(Y_k, omega_0, K, t):
    y = np.real(Y_k[0]) * np.ones(len(t))
    for k in range(1, K+1):
        a_k = 2 * np.real(Y_k[k])      # Factor of 2 to account for -k
        b_k = -2 * np.imag(Y_k[k])

        # Apply Eulers and seperate for hardware realization (C doesn't do j)
        y += a_k * np.cos(k * omega_0 * t) + b_k * np.sin(k * omega_0 * t)
    return y
```
and is called by
```python
on main ❮ python3
Python 3.14.2 (main, Dec 10 2025, 20:09:47) [GCC 14.2.1 20250405] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import dsp_sim_utils as s
>>> import numpy as n
>>> A = 1
>>> B = 3
>>> def x(t):
...     if -(B+10) <= t < 0:
...          return -t / (B+10)
...     elif 0 <= t < (A+10):
...          return 2*t / (A+10)
...     else:
...          return 0
...
>>> Y_k = s.find_fft_k(40, x, 10, 2048, 921, 16500)
>>> T_new = 40 / 16500
>>> w_0 = 2 * n.pi / T_new
>>> t = n.linspace(0, 2*T_new, 10000)
>>> y = s.fft_synth_real(Y_k, w_0, 10, t)
>>> fig, (ax1, ax2) = plt.subplots(2, 1)
>>> ax1.plot(t, y)
>>> ax1.set_title('y_K(t)')
>>> t_x = n.linspace(-20, 20, 10000)
>>> x_vals = n.array([x(ti) for ti in t_x])
>>> ax2.plot(t_x, x_vals)
>>> ax2.set_title('x(t)')
>>> plt.tight_layout()
>>> plt.show()
```
![Alt text](./Artifacts/SDD_301_Artifact_2.png "Figure 1")
