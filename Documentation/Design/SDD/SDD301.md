# Software Design Document 300 | Fourier Series Synthesis on K22F

## Overview
The scope of this document is limeted to describing the theoretical modeling of a Fourier series synthesizer that generates arbitrary periodic waveforms using truncated harmonic summation.

## Parameters


---

## Mathematical Foundation

### Base Signal Definition

$$
x(t) = \begin{cases}
0 & -20 \leq t < -(B + 10) \\
-t/(B + 10) & -(B + 10) \leq t < 0 \\
2t/(A + 10) & 0 \leq t < A + 10 \\
0 & A + 10 \leq t < 20 \\
x(t + 40) & \forall
\end{cases}
$$

Given:
- **A = 1**
- **B = 3**
In MATLAB
```matlab
A = 1;
B = 3;
T = 40;

t = -40:0.01:40;  % 2 periods

% Map t to one period [-20, 20)
t_mod = mod(t + 20, T) - 20;

x = zeros(size(t));

x(t_mod >= -(B+10) & t_mod < 0)      = -t_mod(t_mod >= -(B+10) & t_mod < 0) / (B+10);
x(t_mod >= 0 & t_mod < (A+10))       = 2*t_mod(t_mod >= 0 & t_mod < (A+10)) / (A+10);

plot(t, x);
title('x(t) - 2 Periods');
xlabel('t');
grid on;
```
![Alt text](./Artifacts/SDD_301_Artifact_1.png "Figure 1")

### Signal Characteristics
- **Period:** T = 40 units of time
- **Fundamental frequency:** f₀ = 1/T = 0.025/units Hz
- **Piecewise linear:** Two ramp segments with different slopes
- **DC component:** Non-zero (signal not symmetric about zero)

## Transformed Signal
The output signal is defined as:

$$
y(t) = c_{1} + c_{2} x(c_{3} t)
$$

Where:
- c₁ = DC offset for centering
- c₂ = Amplitude scaling
- c₃ = Time scaling (frequency multiplication)

### Fourier Series Representation
The truncated Fourier series approximation:

$$
y_{K}(t) = \sum_{k=-K}^{K} Y_{k} e^{jk\omega_{0} t}
$$


## Scaling Constants c₁ and c₂

### Objective
Maximize output amplitude while preventing saturation on 12-bit DAC (0-4095 range).

### Analysis
The K22F DAC requires:
- **Output range:** 0 to 4095 (12-bit unsigned)
- **Voltage range:** 0 to 3.3V
- **Buffer:** ~10% headroom to prevent clipping

**DC offset (c₁):**
```
c₁ = 4095/2 = 2047.5 = ~2048
```
Centers the signal at mid-scale.

**Amplitude scaling (c₂):**

Given that x(t) has maximum value max(x) and minimum value min(x), the peak-to-peak amplitude is:
```
A_pp = max(x) - min(x)
```

With 10% headroom:
```
c₂ = 0.9 * (4095/2) / max(|x(t)|)
c₂ = ~1842 / max(|x(t)|)
c₂ = 1842 / 2 = 921
```

**Result:**
- c₁ = 2048
- c₂ = 921

## Frequency Scaling c₃

### Constraints
- **Sample rate:** Fs = 10 kHz
- **Nyquist frequency:** Fs/2 = 5 kHz
- **Signal quality:** Must maintain acceptable waveform for K less than or eqaul to 10

### Analysis
The highest frequency component in yK(t) is:
```
f_max = K × f₀ × c₃
```

For adequate reconstruction with K=10 harmonics, we need significant margin below Nyquist:
```
10 × f₀ × c₃ < 0.9 × (Fs/2) [10% buffer]
10 × (1/40) × c₃ < 4500
c₃ < 18000
```

However, for better signal quality with K=1 (fundamental only), we want the base frequency high enough to be audible/visible:
```
f₀ × c₃ > 100 Hz  [reasonable lower bound]
c₃ > 4000
```

**Recommended value:**
```
c₃ = 4000-18000  [adjust based on MATLAB testing]
```
* Using c₃ = 16500 [so theres a fair margin]

```
>>> 16500 / 40
412.5
>>> 412.5 * 10
4125.0
```
This gives:
- Fundamental: 412.5 Hz (K=1)
- 10th harmonic: 4.125 kHz (K=10)

---

## Fourier Series Coefficients

### Derivation
For a periodic signal with period T, the Fourier series coefficients are:

$$
Y_k = \frac{1}{T} \int_{0}^{T} y(t) e^{-jk\omega_0 t} dt
$$

Since y(t) = c₁ + c₂x(c₃t), and x(t) is piecewise linear:

**DC component (k=0):**

$$
Y_0 = c_1 + \frac{c_2}{T} \int_{0}^{T} x(c_3 t) dt
$$

**Harmonic components (k≠0):**

For the piecewise segments, integration by parts:

$$
\int t e^{-j\omega t} dt = \frac{t}{-j\omega} e^{-j\omega t} - \frac{1}{-j\omega} \int e^{-j\omega t} dt\\
= \frac{-jt}{\omega} e^{-j\omega t} + \frac{1}{\omega^2} e^{-j\omega t}
$$


```python
on main ❮ python
Python 3.14.2 (main, Dec 10 2025, 20:09:47) [GCC 14.2.1 20250405] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import dsp_sim_utils as s
>>> A = 1
>>> B = 3
>>> def x(t):
...     if -(B+10) <= t < 0:
...         return -t / (B+10)
...     elif 0 <= t < (A+10):
...         return 2*t / (A+10)
...     else:
...         return 0
...
>>> s.find_fft_k(40, x, 10)
array([ 4.37500000e-01+0.j        ,  1.29837206e-01-0.09004759j,
       -2.34354926e-01-0.10612265j, -1.14120681e-01+0.01265463j,
        7.60403684e-02+0.07454009j,  4.60652343e-03-0.0299229j ,
       -5.93476414e-02-0.05293962j, -4.36936105e-04+0.0473512j ,
        2.19557396e-02+0.02493691j, -7.12110187e-03-0.0514814j ,
       -1.85370914e-02+0.0026216j ])
>>> 12 + (13/2)
18.5
>>> 18.5/40
0.4625
>>> (12 + (11/2))
17.5
>>> (12 + (11/2)) / 40
0.4375
>>>
```
refer to `../../Simulation/dsp_sim_utils.py` for functions. (I wrote them myself).

