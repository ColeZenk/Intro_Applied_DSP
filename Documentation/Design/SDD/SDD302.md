# Software Design Document 301 | Fourier Integration
## Overview
The scope of this document is limited to describing the hardware integration of the Fourier series synthesizer described in SDD301.

## Mapping Simulation to C
Using the table from SDD301

| k  | a (real)     | b (imag)      |
|----|--------------|---------------|
| 0  | 1216.31250   | 0             |
| 1  | 239.289971   | -165.95771119 |
| 2  | -431.916129  | -195.58403878 |
| 3  | -210.324415  | 23.32248174   |
| 4  | 140.142399   | 137.37739398  |
| 5  | 8.48982269   | -55.14791232  |
| 6  | -109.377703  | -97.56772502  |
| 7  | -0.805273241 | 87.26825469   |
| 8  | 40.4644281   | 45.95872345   |
| 9  | -13.1241907  | -94.88022582  |
| 10 | -34.1638594  | 4.83160338    |

and function:
```python
def fft_synth_real(Y_k, omega_0, K, t):
    y = np.real(Y_k[0]) * np.ones(len(t))
    for k in range(1, K+1):
        a_k = 2 * np.real(Y_k[k])      # Factor of 2 to account for -k
        b_k = -2 * np.imag(Y_k[k])

        # Apply Eulers and seperate for hardware realization (C doesn't do j)
        y += a_k * np.cos(k * omega_0 * t) + b_k * np.sin(k * omega_0 * t)
    return y
```
it roughly translate to C with:

```c
#define REAL 0
#define IMAG 1
#define KMAX 10

static float Y[KMAX+1][2] = {
    { 1216.31250,    0.0          },
    { 239.289971,   -165.95771119 },
    {-431.916129,   -195.58403878 },
    {-210.324415,    23.32248174  },
    { 140.142399,   137.37739398  },
    {   8.48982269, -55.14791232  },
    {-109.377703,   -97.56772502  },
    {  -0.805273241, 87.26825469  },
    {  40.4644281,   45.95872345  },
    { -13.1241907,  -94.88022582  },
    { -34.1638594,    4.83160338  }
};

static uint8_t K_selected = KMAX;

static inline float fft_synth(float t) {
    float y = Y[0][REAL];  // DC term
    for (int k = 1; k <= K_selected; k++) {
        y += 2.0f * Y[k][REAL] * cosf(k * omega_0 * t)
           - 2.0f * Y[k][IMAG] * sinf(k * omega_0 * t);
    }
    return y;
}
```

For all tables to be implemented for adequite run-time switching a K-MAX by SAMPLE_NUM table is required.

```c

void fourier_synth_init(void)
{
    for (int K = 0; K <= KMAX; K++) {
        for (int n = 0; n < PERIOD_SAMPLES; n++) {
            float t = (float)n / FS;
            float y = a_k[0];

            for (int k = 1; k <= K; k++) {   // K+1 harmonics for row K
                y += 2.0f * a_k[k] * cosf(k * OMEGA_0 * t)
                   - 2.0f * b_k[k] * sinf(k * OMEGA_0 * t);
            }

            if (y < 0.0f)    y = 0.0f;
            if (y > 4095.0f) y = 4095.0f;

            lut[K][n] = (uint16_t)y;
        }
    }
}
```
then this can all be stored upon initialization and LUT indexes will be sampled instead of computed and sampled.

## Timing

From SDD301 a fundamental frequency of 450 Hz was calculated as the ideal (allowing 10% margins). However, Adjusting only C_3 instead of the sampling rate may cause discrepencies if FS/F0 does not evaluate to a clean integer. Adjusting the number of samples is a much cleaner approach. As stated in SDD301 the maximum value of F0 is calculated with `C_3 = (Fs/2) / ((1 / T) * K-MAX)`. With a K-MAX of 10 the maximum C_3 is `C_3 = (5000) / (1/4) = 20000` which leaves a fundamental frequency F0 as 500 Hz meaning F_10 = (1 / Nyquist) exactly. When looking at the samples in a period it is exact, `S = 10000 / 500 = 20` which is a clean integer, but F_10 being exactly the Nyquist is a touch risky. A more standard approach is that described in SDD301, of around 10%.

```
S = 10000 / 450 = 22.222
```
Which is not a clean integer! This leaves two options, eat into the buffer a little, or give extra buffer. I chose to round the samples down to 22 since a 10% buffer is plenty of room.
```c
#define FS              10000.0f

#define KMAX            10u
#define T               40.0f
#define PERIOD_SAMPLES  23u

#define F0              (FS / (float)PERIOD_SAMPLES)
#define OMEGA_0         (2.0f * 3.14159265f * F0)
#define C3              F0 * T
```

This calculation yeilds `F0 = 10000/23 = 454.5454 ==> C_3 = 18181.8181`. with F_0 500 being the thoretical limit, `buffer =(1 - (454.545454 / 500)) * 100% = 9.0909%` so ~1% less room.

## Buttons


