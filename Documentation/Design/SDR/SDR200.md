# Software Design Request 200
## Project Number : ECE 444
## Domain | NDSU

**Implementation Due: Fri. Feb. 6**
Proof of Concept : Hardware Demos
Calculations Due: Mon. Feb. 9

1. Using the "digital wire" feature implemented as per SDR100, implement a spectral inverter system mathematically described by

$$
y[n] = (−1)^{n} \times x[n]
$$

Mathematically explain (prove) why this system is a spectral inverter. Using your hardware implementation, show that an input sinusoid of frequency f (where 0 < f < 0.5Fs ) produces an output sinusoid frequency 0.5Fs − f . What kind of output is produced if the input is a square wave? What kind of output is produced if the input is a triangle wave? **CAUTION: You may not be able to implement an ideal spectral inverter given hardware limitations of our DSK. That is, you need to modify the spectral inverter idea to accommodate the dc offset/unipolar nature of the DAC. Carefully explain your modification when writing up your solution to this HW.**

1. Consider a twist on the spectral inverter designed in Prob. 1: let's "kill" every other sample by making it zero, and then, much like the spectral inverter, alternate the sign of every other remaining sample. Taken together, this is equivalent to multiplying samples by the 4-periodic signal that sequences as . . . , 0, 1, 0, −1, . . .. Using your HW #1 "digital wire" as a starting point, hardware-implement this system. Explain the effect of this system on the input signal's spectrum. See how the system responds to the types of input signals (sinusoids, square waves, triangle waves) used in Prob. 1. See the same caution as given in the first problem.

2. Using your HW #1 "digital wire" as a starting point, hardware-implement an "adjustable-quality digital wire". Each ADC sample of your input is represented using a finite number of bits N (N = 12 for the K22F). Mask this result (logical AND with ones in the upper bits, zeros in the lower bits) to produce an N ′ -bit output, where 0 ≤ N ′ ≤ N . You can adjust the bit resolution in code (recompile and download for each change) if you want, but I'd be more impressed if you found a method for run-time adjustment (e.g., select bit resolution using a variable that can be run-time adjusted using a variable watch window or -- more impressively -- change bit resolution by ±1 using input buttons on the DSP board). If interested, I put a "Hints for Pushbuttons and LEDs" document on Blackboard under "Information and Resources".




*NOTE: Students need to demonstrate hardware-based problems (1, 2, and 3) to the instructor. While relevant design details and code should be turned in with the other problems, expect oral questioning during hardware check-off.*
